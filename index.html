<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Jsspecification : js代码高效维护以及规范之一">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jsspecification</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/GerryIsWarrior/jsSpecification">View on GitHub</a>

          <h1 id="project_title">Jsspecification</h1>
          <h2 id="project_tagline">js代码高效维护以及规范之一</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/GerryIsWarrior/jsSpecification/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/GerryIsWarrior/jsSpecification/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="设计思想" class="anchor" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>设计思想</h3>

<p>1.原子思想，即确认每个function就做一件事
  2.归纳思想，将同一类的操作，全部整合到一起
  3.方便维护，可以便于后来人进行快速维护
  4.方便拓展，即可以根据每个不同的项目进行不同的更改
  5.通用前端设计模式，一些前端可以通用的设计模式</p>

<h3>
<a id="具体实现" class="anchor" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>具体实现</h3>

<pre><code>/**
 * Created by gerry.zhong on 2016/10/11.
 */
var gerry =
(function(){
    //创建一个独立的对象，注入所有的方法，包括你想抛出去和不想抛出去的
    var tool = {
        AAAA:function(){},
        BBBB:function(){
            console.log("我只想内部使用，不想给别人用");
        }
    };

    /*
    * 该对象承载所有需要抛出去的对象
    *   1.该对象中的方法可以自己写
    *   2.该对象中的方法可以注入（例子中的tempObj.tool.AA）
    *   3.该对象也可以选择性抛出给使用者需要的方法，也可以隐藏（tool.BBBB）
    * */
    var tempObj ={
        //reader为一些初始化需要的操作，有时候会有注册事件等，或者一些预操作
        reader:function(){
        },
        //注入所有的选择器，方便选择器变化，直接修改该对象中的选择器，而不需要全局去更改
        selector:{
            mySelector:"#mySelector",  //原密码
        },
        //注入所有的接口地址，方便接口变化可以进行，快速变更，不需要全局找引用的对象
        interface:{
            loginUrl:"",
        },
        //注入page中所有的事件，统一管理，建议命名规范：事件_命名，例 click_login
        registerEle:{
            click_login:function(){
                //注册单击事件
            }
        },
        //注入所有ajax请求，页面所有请求，将在这里统一管理，建议命名规范：ajax_命名，例 ajax_login
        /*
        * 该请求中有2种方案,看需求使用
        *  1.不公用一个请求方案
        *  2.公用一个请求，但是回调处理不一样
        * */
        ajaxRequest:{
            //不公用一个请求方案
            ajax_login:function(){
                $.post("","",function(data){
                    tempObj.callback.call_login(data);
                });
            },
            //会有多个业务公用这个请求
            ajax_login_T:function(callback){
                //所有接口地址从interface中获取，callback中tempObj.callback中处理
                $.post("","",callback);
            },
        },
        //处理所有回调函数，针对一个请求，处理一个回调
        callback:{
            //不共用请求处理回调
            call_login:function(data){
                //处理回调
            },
            //公用请求处理回调
            call_login_T:function(){
                var temp = function(){

                };
                tempObj.ajaxRequest.ajax_login_T(temp);
            }
        },
        //所有使用的工具类，如果每个项目都单独的unit.js或者common.js等存放一些公共方法的，这里可以不使用
        // PS:这里存放的只是仅针对于这个页面处理的一些tool，一般没必要抛出去，不过看业务而定
        tool:{
            A:function(){
                console.log("我是自己写的方法");
            },
            AA:tool.AAAA,    //这是我想抛出去给别人用的东西
        },
        //临时缓存存放区域，仅针对本页面，如果跨页面请存放cookie或者localstorage等
        //主要解决有时候会使用页面控件display来缓存当前页面的一些数据
        temp:{

        },
        /*
        * 业务使用区域，针对每个特别的业务去串上面所有的一个个原子
        *   因为上面所有的方法，只是做一件事，这边可以根据业务进行串服务，很简单的
        * */
        firm:{

        }
    };
    /*
    * 闭包抛出去的方法
    * */
    var outputObj =function(){
        //首先执行reader方法，初始化一些操作，比如注册事件啥啥啥的
        tempObj.reader();
        /*
        * 抛出给别人使用的对象
        *   想给别人看和使用的东西，可以注入tempObj对象，就像tool中的AA的方式
        *   不想给别人看和使用的东西，就像内部tool对象中的BBBB方法，你内部可以使用，外部是无法引用的
        * */
        return tempObj;
    }

    //抛出你希望抛出去的对象，因为你掌控了所有，哈哈。
    return new outputObj();
})();
</code></pre>

<h3>
<a id="设计目标" class="anchor" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>设计目标</h3>

<p>代码规范，以及代码可以高效维护</p>

<h3>
<a id="一些方便维护的操作" class="anchor" href="#%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%93%8D%E4%BD%9C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>一些方便维护的操作</h3>

<p>1.如果修改事件，我就去事件中找我需要的事件，
  2.请求要修改，我就去我的请求中去修改，我要变化的请求，
  3.如果回调变了，我就去回调函数中去处理回调，
  4.选择器和接口，就直接去这2个对象中去修改，不需要全局去变化</p>

<ol>
<li>...</li>
</ol>

<h3>
<a id="支持信息" class="anchor" href="#%E6%94%AF%E6%8C%81%E4%BF%A1%E6%81%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>支持信息</h3>

<p>本人，未婚，性别男，爱好女。
职业目标：全栈架构师
博客园博客：<a href="http://www.cnblogs.com/GerryOfZhong/p/5948501.html">http://www.cnblogs.com/GerryOfZhong/p/5948501.html</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Jsspecification maintained by <a href="https://github.com/GerryIsWarrior">GerryIsWarrior</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
